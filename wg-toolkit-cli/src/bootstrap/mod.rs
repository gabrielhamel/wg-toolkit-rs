use std::cmp::Ordering;
use std::io::{self, Write, BufWriter};
use std::collections::HashSet;
use std::fs::{self, File};
use std::borrow::Cow;
use std::path::Path;

use wgtk::res::ResFilesystem;
use wgtk::pxml;

use crate::{BootstrapArgs, CliResult};

mod parse;
mod model;

use model::{Entity, Interface, Method, Model, PropertyFlags, Ty, TyKind, VariableHeaderSize};

// NOTE: For the future, if python bytecode interpretation is needed to automatically
// generate enumeration or try to gather function arguments' names, see:
// https://github.com/python/cpython/blob/main/InternalDocs/interpreter.md


/// Entrypoint.
pub fn cmd_bootstrap(args: BootstrapArgs) -> CliResult<()> {

    let fs = ResFilesystem::new(args.dir)
        .map_err(|e| format!("Failed to open resource filesystem, reason: {e}"))?;
        
    let model = load(fs)
        .map_err(|e| format!("Failed to load model, reason: {e}"))?;
    
    generate(&args.dest, &model)
        .map_err(|e| format!("Failed to generate model, reason: {e}"))?;

    Ok(())

}

fn load(fs: ResFilesystem) -> io::Result<Model> {

    let mut model = Model::default();

    println!("== Reading aliases...");
    let alias_reader = fs.read("scripts/entity_defs/alias.xml")?;
    let alias_elt = pxml::from_reader(alias_reader).unwrap();
    parse::parse_aliases(&alias_elt, &mut model.tys);

    println!("== Reading interfaces...");
    for interface_file in fs.read_dir("scripts/entity_defs/interfaces")? {
        
        let interface_file = interface_file?;
        let Some((interface_name, "")) = interface_file.name().split_once(".def") else {
            continue;
        };

        println!(" = {interface_name}");

        let interface_reader = fs.read(interface_file.path())?;
        let interface_elt = pxml::from_reader(interface_reader).unwrap();
        let interface = parse::parse_interface(&interface_elt, &mut model.tys, interface_name.to_string());
        model.interfaces.push(interface);

    }

    println!("== Reading entities...");
    let entities_reader = fs.read("scripts/entities.xml")?;
    let entities_elt = pxml::from_reader(entities_reader).unwrap();
    let entities_elt = entities_elt.get_child("ClientServerEntities").unwrap().as_element().unwrap();
    for (index, (entity_name, _)) in entities_elt.iter_children_all().enumerate() {
        
        println!(" = {entity_name}");
        let entity_reader = fs.read(format!("scripts/entity_defs/{entity_name}.def"))?;
        let entity_elt = pxml::from_reader(entity_reader).unwrap();
        let entity = parse::parse_entity(&entity_elt, &mut model.tys, index + 1, entity_name.to_string());
        model.entities.push(entity);

    }

    println!("== Types: {}", model.tys.count());

    Ok(model)

}

fn generate(dest_dir: &Path, model: &Model) -> io::Result<()> {
    generate_mod(dest_dir, model)
}

fn generate_mod(mod_dir: &Path, model: &Model) -> io::Result<()> {

    fs::create_dir_all(&mod_dir)?;

    println!("== Writing module...");
    let mod_file = mod_dir.join("mod.rs");
    let mut writer = BufWriter::new(File::create(&mod_file)?);
    writeln!(writer, "#![allow(non_camel_case_types, non_snake_case, unused)]")?;
    writeln!(writer)?;
    writeln!(writer, "//! This module is generated by bootstrap command of the CLI.")?;
    writeln!(writer)?;
    writeln!(writer, "pub mod alias;")?;
    writeln!(writer)?;

    generate_alias(mod_dir, model)?;

    for app in APPS {
        writeln!(writer, "pub mod {};", app.mod_name)?;
        let app_mod_dir = mod_dir.join(app.mod_name);
        generate_app_mod(&app_mod_dir, app, model)?;
    }

    writeln!(writer)?;
    writeln!(writer, "pub mod interface;")?;
    writeln!(writer, "pub mod entity;")?;
    generate_interfaces(mod_dir, model)?;
    generate_entities(mod_dir, model)?;

    Ok(())

}

fn generate_alias(mod_dir: &Path, model: &Model) -> io::Result<()> {

    println!("== Writing aliases...");
    let alias_file = mod_dir.join("alias.rs");
    let mut writer = BufWriter::new(File::create(&alias_file)?);

    writeln!(writer, "pub use glam::{{Vec2, Vec3, Vec4}};")?;
    writeln!(writer)?;

    writeln!(writer, "pub type Python = ();")?;
    writeln!(writer, "pub type Mailbox = ();")?;
    writeln!(writer)?;

    let mut prev_dict = false;

    for ty in model.tys.iter() {

        let identifier = generate_rust_identifier(ty.name());

        match ty.kind() {
            TyKind::Alias(alias_ty) => {
                if prev_dict {
                    writeln!(writer)?;
                    prev_dict = false;
                }
                writeln!(writer, "pub type {identifier} = {};", generate_type_ref(alias_ty))?;
            }
            TyKind::Dict(ty_dict) => {
                prev_dict = true;
                writeln!(writer)?;
                writeln!(writer, "pub struct {identifier} {{")?;
                for prop in &ty_dict.properties {
                    let prop_identifier = generate_rust_identifier(&prop.name);
                    writeln!(writer, "    pub {prop_identifier}: {},", generate_type_ref(&prop.ty))?;
                }
                writeln!(writer, "}}")?;
            }
            TyKind::Array(_) |
            TyKind::Tuple(_) => {
                // Arays and tuples are inlined when generating type ref, so we don't 
                // actually define them.
            }
            _ => {}  // Don't define builtins.
        }

    }

    Ok(())

}

/// From the given type, return a string referencing it, when possible it inlines it.
fn generate_type_ref(ty: &Ty) -> Cow<'_, str> {
    Cow::Borrowed(match ty.kind() {
        TyKind::Int8 => "i8",
        TyKind::Int16 => "i16",
        TyKind::Int32 => "i32",
        TyKind::Int64 => "i64",
        TyKind::UInt8 => "u8",
        TyKind::UInt16 => "u16",
        TyKind::UInt32 => "u32",
        TyKind::UInt64 => "u64",
        TyKind::Float32 => "f32",
        TyKind::Float64 => "f64",
        TyKind::Vector2 => "Vec2",
        TyKind::Vector3 => "Vec3",
        TyKind::Vector4 => "Vec4",
        TyKind::String => "String",
        TyKind::Python => "Python",
        TyKind::Mailbox => "Mailbox",
        TyKind::Array(ty_seq) |
        TyKind::Tuple(ty_seq) => {
            
            let inline = if let Some(size) = ty_seq.size {
                format!("Box<[{}; {size}]>", generate_type_ref(&ty_seq.ty))
            } else {
                format!("Vec<{}>", generate_type_ref(&ty_seq.ty))
            };

            return Cow::Owned(inline);

        }
        _ => ty.name()
    })
}

/// Deterministically generate a Rust-compatible identifier for types or fields.
fn generate_rust_identifier(name: &str) -> Cow<'_, str> {
    match name {
        "type" => Cow::Borrowed("r#type"),
        name => Cow::Borrowed(name),
    }
}

fn generate_app_mod(mod_dir: &Path, app: &App, model: &Model) -> io::Result<()> {

    fs::create_dir_all(&mod_dir)?;
    
    println!("== Writing {} module...", app.mod_name);
    let mod_file = mod_dir.join("mod.rs");
    let mut writer = BufWriter::new(File::create(&mod_file)?);
    
    writeln!(writer, "pub mod interface;")?;
    writeln!(writer, "pub mod entity;")?;

    generate_app_interfaces(mod_dir, app, model)?;
    generate_app_entities(mod_dir, app, model)?;

    Ok(())

}

fn generate_app_interfaces(mod_dir: &Path, app: &App, model: &Model) -> io::Result<()> {
    
    println!(" = Writing {} interfaces...", app.mod_name);
    let interface_file = mod_dir.join("interface.rs");
    let mut writer = BufWriter::new(File::create(&interface_file)?);

    writeln!(writer, "use super::super::alias::*;")?;
    writeln!(writer)?;

    for interface in &model.interfaces {
        generate_app_interface(&mut writer, app, model, interface)?;
    }

    Ok(())

}

fn generate_app_entities(mod_dir: &Path, app: &App, model: &Model) -> io::Result<()> {

    println!(" = Writing {} entities...", app.mod_name);
    let entity_file = mod_dir.join("entity.rs");
    let mut writer = BufWriter::new(File::create(&entity_file)?);

    writeln!(writer, "use wgtk::net::app::common::element::Method;")?;
    writeln!(writer)?;
    writeln!(writer, "use super::super::alias::*;")?;
    writeln!(writer, "use super::interface::*;")?;
    writeln!(writer)?;

    for entity in &model.entities {
        generate_app_entity(&mut writer, app, model, entity)?;
    }

    Ok(())

}

fn generate_app_entity(
    mut writer: impl Write, 
    app: &App,
    model: &Model, 
    entity: &Entity,
) -> io::Result<()> {
    
    generate_app_interface(&mut writer, app, model, &entity.interface)?;

    /// This method recursively register all methods for the entity in order to sort them
    /// later depending on their arguments' size and then compute there exposed id for
    /// the network protocol.
    /// 
    /// IMPORTANT: The initial order of the exposed method is really important because we
    /// will use a stable sort, and some orders should not be changed.
    fn add_internal_methods<'m>(
        app: &App, 
        exposed_methods: &mut Vec<ExposedMethod<'m>>, 
        model: &'m Model, 
        interface: &'m Interface,
        path: &[String],
    ) {
        
        for method in (app.interface_methods)(interface) {
            if method.exposed_to_all_clients | method.exposed_to_own_client {
                exposed_methods.push(ExposedMethod {
                    method,
                    path: path.to_vec(),
                    stream_size: compute_method_stream_size(method),
                });
            }
        }

        let mut path = path.to_vec();
        
        for interface_name in &interface.implements {

            let interface = model.interfaces.iter()
                .find(|i| &i.name == interface_name)
                .expect("unknown implemented interface");

            path.push(interface_name.clone());
            add_internal_methods(app, exposed_methods, model, interface, &path);
            path.pop();

        }

    }

    let mut methods = Vec::new();
    add_internal_methods(app, &mut methods, model, &entity.interface, &[]);

    // We want to sort fixed methods first and variable last, and then sort between
    // their configured fixed or variable size.
    methods.sort_by(|a, b| {
        match (a.stream_size, b.stream_size) {
            (StreamSize::Variable(a_size), StreamSize::Variable(b_size)) => 
                a_size.cmp(&b_size),
            (StreamSize::Fixed(a_size), StreamSize::Fixed(b_size)) =>
                a_size.cmp(&b_size),
            (StreamSize::Fixed(_), StreamSize::Variable(_)) =>
                Ordering::Less,
            (StreamSize::Variable(_), StreamSize::Fixed(_)) =>
                Ordering::Greater,
        }
    });

    for (exposed_id, method) in methods.iter().enumerate() {
        writeln!(writer, "// {exposed_id}: {} [{:?}] @ {:?}", method.method.name, method.stream_size, method.path)?;
    }
    writeln!(writer)?;

    // writeln!(writer, "impl Method for {}Method {{", entity.interface.name)?;
    // writeln!(writer, "}}")?;
    // writeln!(writer)?;
    
    Ok(())

}

fn generate_app_interface(
    writer: impl Write, 
    app: &App,
    model: &Model, 
    interface: &Interface,
) -> io::Result<()> {
    generate_app_interface_methods(writer, app, model, interface)?;
    Ok(())
}

fn generate_app_interface_methods(
    mut writer: impl Write, 
    app: &App,
    model: &Model, 
    interface: &Interface,
) -> io::Result<()> {

    let methods = (app.interface_methods)(interface);
    
    writeln!(writer, "/// Methods for {} on {} component", interface.name, app.mod_name)?;
    writeln!(writer, "pub enum {}Method {{ ", interface.name)?;

    for interface_name in &interface.implements {
        writeln!(writer, "    {interface_name}({interface_name}Method),")?;
    }

    let mut unique_names = HashSet::new();

    for (idx, method) in methods.iter().enumerate() {
        
        // Ignoring methods that are not exposed, we only care about methods exposed for
        // the network protocol.
        if !method.exposed_to_all_clients && !method.exposed_to_own_client {
            continue;
        }

        if !unique_names.insert(method.name.as_str()) {
            continue;
        }

        write!(writer, "    {}(", method.name)?;
        for (arg_idx, arg) in method.args.iter().enumerate() {
            if arg_idx != 0 {
                write!(writer, ", ")?;
            }
            write!(writer, "{}", generate_type_ref(&arg.ty))?;
        }
        write!(writer, "), // idx({idx})")?;

        writeln!(writer)?;
        
    }

    writeln!(writer, "}}")?;
    writeln!(writer)?;

    Ok(())

}

fn generate_interfaces(mod_dir: &Path, model: &Model) -> io::Result<()> {

    println!("== Writing interfaces...");
    let interface_file = mod_dir.join("interface.rs");
    let mut writer = BufWriter::new(File::create(&interface_file)?);

    writeln!(writer, "use super::alias::*;")?;
    writeln!(writer, "use super::{{base, cell, client}};")?;
    writeln!(writer)?;

    for interface in &model.interfaces {
        generate_interface(&mut writer, model, interface)?;
    }

    Ok(())

}

fn generate_entities(mod_dir: &Path, model: &Model) -> io::Result<()> {

    println!("== Writing entities...");
    let entity_file = mod_dir.join("entity.rs");
    let mut writer = BufWriter::new(File::create(&entity_file)?);

    writeln!(writer, "use wgtk::net::app::common::element::Entity;")?;
    writeln!(writer)?;
    writeln!(writer, "use super::alias::*;")?;
    writeln!(writer, "use super::interface::*;")?;
    writeln!(writer, "use super::{{base, cell, client}};")?;
    writeln!(writer)?;

    for entity in &model.entities {
        generate_entity(&mut writer, model, entity)?;
    }

    Ok(())

}

fn generate_entity(
    mut writer: impl Write, 
    model: &Model, 
    entity: &Entity,
) -> io::Result<()> {

    generate_interface(&mut writer, model, &entity.interface)?;

    // TODO:
    // writeln!(writer, "impl Entity for {} {{", entity.interface.name)?;
    // writeln!(writer, "    const ID: u16 = {};", entity.id)?;
    // writeln!(writer, "    type ClientMethod = client::entity::{}Method;", entity.interface.name)?;
    // writeln!(writer, "    type BaseMethod = base::entity::{}Method;", entity.interface.name)?;
    // writeln!(writer, "    type CellMethod = cell::entity::{}Method;", entity.interface.name)?;
    // writeln!(writer, "}}")?;
    // writeln!(writer)?;
    
    Ok(())

}

fn generate_interface(
    mut writer: impl Write, 
    model: &Model, 
    interface: &Interface,
) -> io::Result<()> {
    
    writeln!(writer, "/// Interface {}", interface.name)?;
    writeln!(writer, "#[derive(Debug, Default)]")?;
    writeln!(writer, "pub struct {} {{", interface.name)?;
    
    for interface_name in &interface.implements {
        writeln!(writer, "    pub i_{interface_name}: {interface_name},")?;
    }

    // TODO: client-side fields

    writeln!(writer, "}}")?;
    writeln!(writer)?;

    // for property in &interface.properties {

    //     // if !(app.check_property_flags)(property.flags) {
    //     //     continue;
    //     // }

    //     // write!(writer, "    {}: {}, //", property.name, gen_model.type_name(property.ty))?;
    //     // properties_count += 1;
        
    //     // match property.flags {
    //     //     PropertyFlags::None => (),
    //     //     PropertyFlags::Base => write!(writer, " base")?,
    //     //     PropertyFlags::BaseAndClient => write!(writer, " base and client")?,
    //     //     PropertyFlags::OwnClient => write!(writer, " own client")?,
    //     //     PropertyFlags::CellPrivate => write!(writer, " cell private")?,
    //     //     PropertyFlags::CellPublic => write!(writer, " cell public")?,
    //     //     PropertyFlags::AllClients => write!(writer, " all clients")?,
    //     // }
    //     // writeln!(writer)?;

    // }
    // writeln!(writer, "}}")?;
    // writeln!(writer)?;

    Ok(())

}

/// Return the stream size of this type, none if the type has no known size.
fn compute_type_stream_size(ty: &Ty) -> Option<usize> {
    match ty.kind() {
        TyKind::Int8 | TyKind::UInt8 => Some(1),
        TyKind::Int16 | TyKind::UInt16 => Some(2),
        TyKind::Int32 | TyKind::UInt32 => Some(4),
        TyKind::Int64 | TyKind::UInt64 => Some(8),
        TyKind::Float32 => Some(4),
        TyKind::Float64 => Some(8),
        TyKind::Vector2 => Some(4 * 2),
        TyKind::Vector3 => Some(4 * 3),
        TyKind::Vector4 => Some(4 * 4),
        TyKind::String => None,
        TyKind::Python => None,
        TyKind::Mailbox => None,  // TODO:
        TyKind::Alias(ty) => 
            compute_type_stream_size(ty),
        TyKind::Dict(ty_dict) => 
            ty_dict.properties.iter()
                .map(|prop| compute_type_stream_size(&prop.ty))
                .sum(),  // Using sum on Option: any None will result in a None.
        TyKind::Array(ty_seq) |
        TyKind::Tuple(ty_seq) => 
            ty_seq.size.map(|len| len as usize)
                .zip(compute_type_stream_size(&ty_seq.ty))
                .map(|(len, element_size)| len * element_size)
    }
}

/// This returns the preferred stream size.
fn compute_method_stream_size(method: &Method) -> StreamSize {
    
    let size = method.args.iter()
        .map(|arg| compute_type_stream_size(&arg.ty))
        .sum::<Option<usize>>();

    match size {
        Some(size) => StreamSize::Fixed(size),
        // TODO: Also return this is exposed and has sub msg id?
        None => StreamSize::Variable(method.variable_header_size)
    }

}

/// Definition of a type of application, this type is used to create one module per 
/// application to register their interfaces and entities.
#[derive(Debug)]
struct App {
    mod_name: &'static str,
    interface_methods: fn(&Interface) -> &[Method],
    check_property_flags: fn(PropertyFlags) -> bool,
}

const APPS: &[App] = &[
    App {
        mod_name: "client",
        interface_methods: |i| &i.client_methods,
        check_property_flags: |p| matches!(p, PropertyFlags::AllClients | PropertyFlags::BaseAndClient | PropertyFlags::OwnClient),
    },
    App {
        mod_name: "base",
        interface_methods: |i| &i.base_methods,
        check_property_flags: |p| matches!(p, PropertyFlags::Base | PropertyFlags::BaseAndClient),
    },
    App {
        mod_name: "cell",
        interface_methods: |i| &i.cell_methods,
        check_property_flags: |p| matches!(p, PropertyFlags::CellPrivate | PropertyFlags::CellPublic),
    },
];

/// An exposed method for the network protocol, this is used to list all exposed methods
/// on an entity and then compute the methods' exposed ids.
#[derive(Debug)]
struct ExposedMethod<'a> {
    /// The actual method definition.
    method: &'a Method,
    /// The path to this method, containing a hierarchy of interfaces name where the
    /// function is actually located.
    path: Vec<String>,
    /// Stream size for this method arguments.
    stream_size: StreamSize,
}

#[derive(Debug, Copy, Clone, PartialEq, Eq)]
enum StreamSize {
    Fixed(usize),
    Variable(VariableHeaderSize),
}
